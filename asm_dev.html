<html>
<head>

    <link rel="stylesheet" href="style.css">

</head>
<body>
    

    <section>
        <br><h1>Assembly dokumentation</h1><br>
    </section>


    <section>
        <h2>Základní struktury</h2>
        <p>U Assembleru je základní strukturan rozdílná podle toho v jaké arhitektuře pracujeme. A to jako první zda v x86 nebo v ARM a poté zda 32 bits nebo 64 bits.</p>
        <p>Struktura pro x86_64:</p>
        <div class="code">
            <span class="codename">&nbsp;module.asm; module.s</span><br><br>
            <div>
                <span>bits 64</span>
                <br><span>section .data</span>
                <br><span>; zde se zapisují proměnné</span>
                <br>
                <br>
                <br><span>section .text</span>
                <br><span>; zde se zapisuje kod programu jako jsou funkce</span>
            </div>
        </div>
    </section>


    <br><section>
        <h2>Propojení s C/C++</h2>
        <p>C/C++ dokumentace <a href="c_dev.html">zde</a></p>
        <h3>Proměnné:</h3>
        <p>Proměnné se deklarují pomocí <span>extern</span> v section <span>.data</span>.</p>
        <div class="code">
            <span class="codename">&nbsp;module.asm; module.s</span><br><br>
            <div>
                <span>section .data</span>
                <br><span>&nbsp;&nbsp;extern g_var</span>
            </div>
        </div>
        <h3>Funkce:</h3>
        <p>Funkce mají stejnou deklaraci a volání jak klasické ASM funkce. Declarují se v section <span>.text</span> pomocí <span>global</span>, která ukazuje, že dnná funkce je globální.</p>
        <div class="code">
            <span class="codename">&nbsp;module.asm; module.s</span><br><br>
            <div>
                <span>section .text</span>
                <br><span>&nbsp;&nbsp;global g_func</span>
                <br>
                <br>
                <br><span>g_func:</span>
                <br>
                <br><span>ret  ; ukončení funkce, aby nebyla v loopu</span>
            </div>
        </div>
    </section>


    <br><section>
        <h2>Registry</h2>
        <p>Vždy se berou spodní bity</p>
        <img src="registers.png" alt="">
    </section>


    <br><section>
        <h2>Příkazy</h2>
        <h3>Základní:</h3>
        <ul>
            <li><code><span>mov</span></code> - přesouvá proměnné do registru stejné velikosti</li>
            <li><code><span>movzx</span></code> - přesouvá proměnné do většího registru než je proměnná sama a prázdné místo vyplní nulami</li>
            <li><code><span>movsx</span></code> - téměř totožné jako movzx akorát že zachovává znaménko -+</li>
            <br>
            <li><code><span>int</span></code> - je to interupt neboli přerušení programu volá externě podle zadané hodnoty co se má stát a udělat</li>
            <li><code><span>add</span></code> - je to přičtení k hodnotě</li>
            <li><code><span>sub</span></code> - je to odečtení od hodnoty</li>
            <br>
            <li><code><span>cmp</span></code> - dělá to samé co sub akorát že výsledek zahodí, používá se u podmíněných skoků <code><span>JE</span></code></li>
            <li><code><span>dec</span></code> - od hodnoty odečte 1</li>
            <li><code><span>neg</span></code> - změní znaménko</li>
            <br>
            <li><code><span>and</span></code> - logický spučin, když na pozici oba vstupy mají 1 tak výsledek je 1, používá se k masce</li>
            <li><code><span>or</span></code> - logický součet, kdzž alespoň jedna hodnota je jedna tak je výsledek 1 jinak 0</li>
            <li><code><span>xor</span></code> - dá jedna pokud se logické proměnné liší jinak dá 0</li>
            <li><code><span>not</span></code> - bitová inverze, otočí všechny bity</li>
            <li><code><span>test</span></code> - dělá to co and ale výsledek zahodí stejně jako cmp</li>
            <br>
            <li><code><span>shl</span></code> - bitový posun doleva</li>
            <li><code><span>shr</span></code> - bitový posun doprava</li>
        </ul>
        <h3>Podmíněné skoky:</h3>
        <table>
            <thead>
                <tr>
                    <th>ASM Skok</th>
                    <th>Význam anglicky</th>
                    <th>Kdy skočí (C++ ekvivalent)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>JE</code> / <code>JZ</code></td>
                    <td>Jump if Equal / Zero</td>
                    <td><code>==</code> (Jsou si rovny)</td>
                </tr>
                <tr>
                    <td><code>JNE</code> / <code>JNZ</code></td>
                    <td>Jump if Not Equal / Not Zero&nbsp;&nbsp;&nbsp;</td>
                    <td><code>!=</code> (Nejsou si rovny)</td>
                </tr>
                <tr>
                    <td><code>JG</code></td>
                    <td>Jump if Greater</td>
                    <td><code>&gt;</code> (První je VĚTŠÍ než druhé)</td>
                </tr>
                <tr>
                    <td><code>JGE&nbsp;&nbsp;&nbsp;</code></td>
                    <td>Jump if Greater or Equal</td>
                    <td><code>&gt;=</code> (Větší nebo rovno)</td>
                </tr>
                <tr>
                    <td><code>JL</code></td>
                    <td>Jump if Less</td>
                    <td><code>&lt;</code> (První je MENŠÍ než druhé)</td>
                </tr>
                <tr>
                    <td><code>JLE</code></td>
                    <td>Jump if Less or Equal</td>
                    <td><code>&lt;=</code> (Menší nebo rovno)</td>
                </tr>
            </tbody>
        </table>
    </section>


    <br><br><section>
        <h2>Pravidla</h2>
        <ul>
            <li>Nemůžeš přesouvat data přímo z paměti do paměti</li>
            <li>Nemůžeš měnit velikost dat (jako to dělá <code><span>MOVSX</span></code>) a rovnou je u toho cpát do paměti (musíš to roztáhnout v registru a pak to tam uložit)</li>
            <li>Většina operací vyžaduje, aby alespoň jeden z operandů (cíl nebo zdroj) byl registr v procesoru</li>
        </ul>
        <h3>Načítání parametrů z funkce (pro první 4 parametry) a vrácení parametrů</h3>
        <p>Parametry se načítají automaticky do konkrétního registru, specificky pro část, která odpovídá velikosti danému datovému typu.</p>
        <h4>Načítací parametry:</h4>
        <ul>
            <li>1. parametr - RDI</li>
            <li>2. parametr - RSI</li>
            <li>3. parametr - RDX</li>
            <li>4. parametr - RCX</li>
            <li>5. + - R8 .atd</li>
        </ul>
        <h4>Vracející se hodnota</h4>
        <ul>
            <li>long, uint64_t, ukazatele - RAX</li>
            <li>int, uint32_t - EAX</li>
            <li>short, uint16_t - AX</li>
            <li>char, uint8_t, bool - AL</li>
        </ul>
        <p>Primárně se hodnoty vrací přes reg RAX</p>
    </section>


    <br><section>
        <h2>Posuny</h2>
        <p>Pro posun v danné proměnné sp požívá <code><span>+ *</span></code> a to každý jiným způsobem.</p>
        <ul>
            <li><code><span>čísla</span></code> - čísla 1-9 vytváří posun o bajtech a 1 bajt má 8 bitů</li>
            <li><code><span>+</span></code> - příčteš číslo k proměnné a tím posuneš o počet bajtů</li>
            <li><code><span>*</span></code> - dává se za +číslo a to podstatě, když posuneš něco tak to musí být o velikost celé hodnoty kterou chceš posunout, takže pokud máš pole které má Unit16 a dáš +1 tak posuneš o 8 bitů a né o velikost celého pole takže musíž posunout o celou velikost pole a násobením *2 dorovnáš k dané velikosti a tudíž +1*2 posuneš o 16bitů do druhého prvku a u +2*2 posuneš o 32 bitů neboli do prvku třetího</li>
        </ul>
        <p><code><span style="color: rgb(168, 225, 251)">[promena + posun * hodnota_pro_dorovnani_velikosti]</span></code></p>
    </section>


    <br><section>
        <h2>Další dokumentace</h2>
        <a href="#">https://www.tutorialspoint.com/assembly_programming/index.html</a><br>
    </section>

    
</body>
</html>