<html>
<head>

    <link rel="stylesheet" href="style.css">

</head>
<body>
    

    <section>
        <br><h1>Assembly dokumentation</h1><br>
    </section>


    <section>
        <h2>Základní struktury</h2>
        <p>U Assembleru je základní strukturan rozdílná podle toho v jaké arhitektuře pracujeme. A to jako první zda v x86 nebo v ARM a poté zda 32 bits nebo 64 bits.</p>
        <p>Struktura pro x86_64:</p>
        <div class="code">
            <span class="codename">&nbsp;module.asm; module.s</span><br><br>
            <div>
                <span>bits 64</span>
                <br><span>section .data</span>
                <br><span>; zde se zapisují proměnné</span>
                <br>
                <br>
                <br><span>section .text</span>
                <br><span>; zde se zapisuje kod programu jako jsou funkce</span>
            </div>
        </div>
    </section>


    <br><section>
        <h2>Propojení s C/C++</h2>
        <p>C/C++ dokumentace <a href="c_dev.html">zde</a></p>
        <h3>Proměnné:</h3>
        <p>Proměnné se deklarují pomocí <span>extern</span> v section <span>.data</span>.</p>
        <div class="code">
            <span class="codename">&nbsp;module.asm; module.s</span><br><br>
            <div>
                <span>section .data</span>
                <br><span>&nbsp;&nbsp;extern g_var</span>
            </div>
        </div>
        <h3>Funkce:</h3>
        <p>Funkce mají stejnou deklaraci a volání jak klasické ASM funkce. Declarují se v section <span>.text</span> pomocí <span>global</span>, která ukazuje, že dnná funkce je globální.</p>
        <div class="code">
            <span class="codename">&nbsp;module.asm; module.s</span><br><br>
            <div>
                <span>section .text</span>
                <br><span>&nbsp;&nbsp;global g_func</span>
                <br>
                <br>
                <br><span>g_func:</span>
                <br>
                <br><span>ret  ; ukončení funkce, aby nebyla v loopu</span>
            </div>
        </div>
    </section>


    <br><section>
        <h2>Registry</h2>
        <p>Vždy se berou spodní bity</p>
        <img src="registers.png" alt="">
    </section>


    <br><section>
        <h2>Příkazy</h2>
        <h3>Základní:</h3>
        <ul>
            <li><code><span>mov</span></code> - přesouvá proměnné do registru stejné velikosti</li>
            <li><code><span>movzx</span></code> - přesouvá proměnné do většího registru než je proměnná sama a prázdné místo vyplní nulami</li>
            <li><code><span>movsx</span></code> - téměř totožné jako movzx akorát že zachovává znaménko -+</li>
            <br>
            <li><code><span>int</span></code> - je to interupt neboli přerušení programu volá externě podle zadané hodnoty co se má stát a udělat</li>
            <li><code><span>add</span></code> - je to přičtení k hodnotě</li>
            <li><code><span>sub</span></code> - je to odečtení od hodnoty</li>
            <br>
            <li><code><span>cmp</span></code> - dělá to samé co sub akorát že výsledek zahodí, používá se u podmíněných skoků <code><span>JE</span></code></li>
            <li><code><span>dec</span></code> - od hodnoty odečte 1</li>
            <li><code><span>neg</span></code> - změní znaménko</li>
            <br>
            <li><code><span>and</span></code> - logický spučin, když na pozici oba vstupy mají 1 tak výsledek je 1, používá se k masce</li>
            <li><code><span>or</span></code> - logický součet, kdzž alespoň jedna hodnota je jedna tak je výsledek 1 jinak 0</li>
            <li><code><span>xor</span></code> - dá jedna pokud se logické proměnné liší jinak dá 0</li>
            <li><code><span>not</span></code> - bitová inverze, otočí všechny bity</li>
            <li><code><span>test</span></code> - dělá to co and ale výsledek zahodí stejně jako cmp</li>
            <br>
            <li><code><span>shl</span></code> - bitový posun doleva</li>
            <li><code><span>shr</span></code> - bitový posun doprava</li>
        </ul>
        <h3>Podmíněné skoky:</h3>
        <p>Podmíněné skoky reagují na předchozí příkaz:</p>
                <div class="code">
            <span class="codename">&nbsp;module.asm; module.s</span><br><br>
            <div>
                <span>func_nejaka:</span>
                <br><span>&nbsp;&nbsp;cmp rax, rsi</span>
                <br><span>&nbsp;&nbsp;jge .hotovo</span>
            </div>
        </div>
        <ul>
            <li><span><code>JE / JZ</code></span> - Jump if Equal / Zero</li>
            <li><span><code>JB/JNAE/JC</code></span> - menší než, není větší nebo rovno</li>
            <li><span><code>JNB/JAE/JNC</code></span> - není menší, větší nebo rovno,</li>
            <li><span><code>JBE/JNA</code></span> - menší nebo rovno, není větší</li>
            <li><span><code>JNBE/JA</code></span> - není menší nebo rovno, je větší</li>
            <li><span><code>JL/JNGE</code></span> - menší než, není větší nebo rovno</li>
            <li><span><code>JNL/JGE</code></span> - není menší, větší nebo rovno</li>
            <li><span><code>JLE/JNG</code></span> - menší nebo rovno, není větší</li>
            <li><span><code>JNLE/JG</code></span> - není menší nebo rovno, je větší.</li>
        </ul>


    <br><section>
        <h2>Pravidla</h2>
        <ul>
            <li>Nemůžeš přesouvat data přímo z paměti do paměti</li>
            <li>Nemůžeš měnit velikost dat (jako to dělá <code><span>MOVSX</span></code>) a rovnou je u toho cpát do paměti (musíš to roztáhnout v registru a pak to tam uložit)</li>
            <li>Většina operací vyžaduje, aby alespoň jeden z operandů (cíl nebo zdroj) byl registr v procesoru</li>
            <li>Na některé registry se nesahá - pokud se na ně sáhne tak se může vše posrat <b><span>BACHA!!!</span> -> <span>RSB</span> a <span>RBP</span> na ně se nesahá, jsou posvátné</b></li>
        </ul>
        <h3>Načítání parametrů z funkce (pro první 4 parametry) a vrácení parametrů</h3>
        <p>Parametry se načítají automaticky do konkrétního registru, specificky pro část, která odpovídá velikosti danému datovému typu.</p>
        <h4>Načítací parametry:</h4>
        <ul>
            <li>1. parametr - RDI</li>
            <li>2. parametr - RSI</li>
            <li>3. parametr - RDX</li>
            <li>4. parametr - RCX</li>
            <li>5. + - R8 .atd</li>
        </ul>
        <h4>Vracející se hodnota</h4>
        <ul>
            <li>long, uint64_t, ukazatele - RAX</li>
            <li>int, uint32_t - EAX</li>
            <li>short, uint16_t - AX</li>
            <li>char, uint8_t, bool - AL</li>
        </ul>
        <p>Primárně se hodnoty vrací přes reg RAX</p>
    </section>


    <br><section>
        <h2>Posuny</h2>
        <p>Pro posun v danné proměnné sp požívá <code><span>+ *</span></code> a to každý jiným způsobem.</p>
        <ul>
            <li><code><span>čísla</span></code> - čísla 1-9 vytváří posun o bajtech a 1 bajt má 8 bitů</li>
            <li><code><span>+</span></code> - příčteš číslo k proměnné a tím posuneš o počet bajtů</li>
            <li><code><span>*</span></code> - dává se za +číslo a to podstatě, když posuneš něco tak to musí být o velikost celé hodnoty kterou chceš posunout, takže pokud máš pole které má Unit16 a dáš +1 tak posuneš o 8 bitů a né o velikost celého pole takže musíž posunout o celou velikost pole a násobením *2 dorovnáš k dané velikosti a tudíž +1*2 posuneš o 16bitů do druhého prvku a u +2*2 posuneš o 32 bitů neboli do prvku třetího. můž s násbyt dle 2 na n -> 1, 2, 4, 8</li>
        </ul>
        <p><code><span style="color: rgb(168, 225, 251)">[promena + posun * hodnota_pro_dorovnani_velikosti]</span></code></p>
    </section>


    <br><section>
        <h2>Další dokumentace</h2>
        <a href="#">https://www.tutorialspoint.com/assembly_programming/index.html</a><br>
    </section>

    
</body>
</html>